# USEFUL CLASSES
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from copy import deepcopy
from Lab07 import utils_and_param as up

# free = 1
# occupied = 0


class SignalInformation:

    def __init__(self, path):
        self.signal_power = 1.0e-03  # float
        self.noise_power = 0.0  # float
        self.latency = 0.0  # float
        self.path = path  # list[string]

    def update_powlat(self, s_power, n_power, latency):
        # update powers and latency
        self.signal_power += s_power
        self.noise_power += n_power
        self.latency += latency
        return self.signal_power, self.noise_power, self.latency

    def update_path(self):
        # remove first element of the list
        self.path = self.path[1:]
        # return self.path


class Node:

    def __init__(self, label, dictionary):
        self.label = label                                      # string
        self.position = dictionary['position']                  # tuple(float, float)
        self.connected_nodes = dictionary['connected_nodes']    # list[string]
        self.successive = {}                                    # dict[Line]
        self.switching_matrix = None                            # LAB 6 - dict[dict[]]
        if 'transceiver' in dictionary.keys():                  # LAB 7 - string
            self.transceiver = dictionary['transceiver']
        else:
            self.transceiver = 'fixed_rate'

    def propagate(self, lightpath):
        # LAB 7
        # set side channel occupancy
        if len(lightpath.path) > 2:
            if lightpath.channel+1 < 10:
                self.successive[lightpath.path[:2]].successive[lightpath.path[1]].switching_matrix[lightpath.path[0]][
                    lightpath.path[2]][lightpath.channel+1] = up.OCCUPIED
            if lightpath.channel-1 >= 0:
                self.successive[lightpath.path[:2]].successive[lightpath.path[1]].switching_matrix[lightpath.path[0]][
                    lightpath.path[2]][lightpath.channel-1] = up.OCCUPIED

        lightpath.update_path()
        if lightpath.path != '':
            # call the successive element propagate method, accordingly to the specified path.
            next_label = lightpath.path[0]
            self.successive[self.label + next_label].propagate(lightpath)

    # LAB 5
    def probe(self, lightpath):
        lightpath.update_path()
        if lightpath.path != '':
            # call the successive element probe method, accordingly to the specified path.
            next_label = lightpath.path[0]
            self.successive[self.label + next_label].probe(lightpath)


class Line:

    def __init__(self, label, length):
        self.label = label  # string
        self.length = length  # float
        self.successive = {}  # dict[]
        self.state = np.array([up.FREE] * 10)  # string - LAB 4 - LAB 5 - LAB 6
        self.n_amplifiers = 1 + np.ceil(self.length/up.DIST_BTW_AMP)    # LAB 8
        self.n_span = self.n_amplifiers - 1
        self.amp_gain = 10 ** (up.AMP_GAIN/10)    # linear units
        self.amp_nf = 10 ** (up.AMP_NF/10)        # linear units
        self.alpha = up.ALPHA_dB
        self.beta_2 = up.BETA_2
        self.gamma = up.GAMMA

    def latency_generation(self):
        return self.length / ((2 / 3) * up.c)

    def noise_generation(self, signal_power):
        return 1e-9 * signal_power * self.length

    def propagate(self, lightpath):
        """
            Method to propagate a lightpath on all lines along a path
        """
        # Update power, noise and latency added by the line
        lightpath.update_powlat(0, self.noise_generation(lightpath.signal_power), self.latency_generation())
        # Set line status to occupied then propagate signal - LAB 4
        self.state[lightpath.channel] = up.OCCUPIED  # LAB 5
        next_label = lightpath.path[0]
        self.successive[next_label].propagate(lightpath)

    # LAB 5
    def probe(self, lightpath):
        """
            Method to propagate a lightpath on all lines along a path without occupying them
        """
        # Update power, noise and latency added by the line
        lightpath.update_powlat(0, self.noise_generation(lightpath.signal_power), self.latency_generation())
        # Set next line
        next_label = lightpath.path[0]
        self.successive[next_label].probe(lightpath)

    # LAB 8
    def ase_generation(self):
        """
        evaluates the total amount of amplified spontaneous emissions (ASE) in linear units generated by the amplifiers
        supposing that a cascade of amplifiers introduces a noise amount which follows the expression:
        ASE = N (hf Bn NF [G − 1])
        where N is the number of amplifiers, h is the Plank constant, f is the frequency which would be fixed to
        193.414 THz (C-band center), Bn is the noise bandwidth fixed to 12.5 GHz, N F and G are the amplifier noise
        figure and gain, respectively.
        :return: total ASE in linear units
        """
        ase = self.n_amplifiers * (up.h_plank * up.CENTER_F * up.Bn * self.amp_nf * (self.amp_gain-1))
        return ase

    def nli_generation(self, lightpath):
        """
        evaluates the total amount generated by the nonlinear interface noise using the formula (in linear units):
        NLI = P * ch3 * η_nli * N_span
        :return: NLI
        """
        eta_nli = (16 / (17*up.pi)) * \
                  np.log(((up.pi**2) / 2) * (up.BETA_2 * (up.Rs**2) / up.alpha_db2lin(up.ALPHA_dB)) * (len(self.state)**(2*up.Rs / up.DELTA_F))) * \
                  ((up.GAMMA**2) / (4*up.alpha_db2lin(up.ALPHA_dB)*up.BETA_2)) * (1/(up.Rs**3))
        return (lightpath.signal_power**3) * eta_nli * n_span


class Network:

    def __init__(self, my_dict):
        self.nodes = {}
        self.lines = {}
        self.weighted_paths = pd.DataFrame()
        self.route_space = pd.DataFrame()
        self.default_switching_matrices = {}

        for key in my_dict:
            self.nodes[key] = Node(key, my_dict[key])

            # LAB7
            self.default_switching_matrices[key] = my_dict[key]['switching_matrix']
            # easier way to build the switching matrix BUT needs np.array() before multiplication taken
            # self.nodes[key].switching_matrix = np.array(my_dict[key]['switching_matrix'])
            first = True
            for con_node in my_dict[key]['switching_matrix']:
                if first:
                    first = False
                    self.nodes[key].switching_matrix = self.build_switching_matrix(key, con_node, my_dict)
                else:
                    self.nodes[key].switching_matrix.update(self.build_switching_matrix(key, con_node, my_dict))
            #

            for element in self.nodes[key].connected_nodes:
                line_label = (key + element)
                pos = np.array(self.nodes[key].position)
                next_pos = np.array(my_dict[element]['position'])
                distance = np.sqrt(np.sum((pos - next_pos) ** 2))

                self.lines[line_label] = Line(line_label, distance)

    def connect(self):
        for label in self.nodes:
            node = self.nodes[label]
            # first = True
            for con_node in node.connected_nodes:
                con_line = node.label + con_node
                node.successive[con_line] = self.lines[con_line]
                # if first:
                #     first = False
                #     node.switching_matrix = self.build_switching_matrix(label, con_node)
                # else:
                #     node.switching_matrix.update(self.build_switching_matrix(label, con_node))

        for label in self.lines:
            line = self.lines[label]
            line.successive[line.label[0]] = self.nodes[line.label[0]]
            line.successive[line.label[1]] = self.nodes[line.label[1]]

    def find_paths(self, node1, node2):
        """
            Given two node labels, this function returns all the paths that connect the two nodes
            as list of node labels.
            The admissible paths have to cross any node at most once.
        """
        available_path = []
        for i in range(len(self.nodes.keys()) - 1):
            if i == 0:
                possible_paths = self.generate(node1, self.nodes[node1].connected_nodes)
                copy_possible_paths = possible_paths
                for path in copy_possible_paths:
                    if path[-1] not in self.nodes[node1].connected_nodes:
                        possible_paths.remove(path)
                    elif path[-1] == node2:
                        available_path.append(path)
            else:
                elem = range(len(possible_paths))
                for j in elem:
                    derived_paths = self.generate(possible_paths[0], self.nodes[possible_paths[0][-1]].connected_nodes)
                    for path in derived_paths:
                        aaa = path[-1]
                        aab = path[-2]
                        aac = self.nodes[path[-2]].connected_nodes
                        if path[-1] not in self.nodes[path[-2]].connected_nodes:
                            derived_paths.remove(path)
                        elif path[-1] == node2:
                            available_path.append(path)
                            derived_paths.remove(path)
                    possible_paths.pop(0)
                    possible_paths += derived_paths
        return available_path

    def generate(self, string1, labels):
        out = []
        for letter in labels:
            if letter not in string1:
                out.append(string1 + letter)
        return out

    def propagate(self, lightpath):
        """
            This function has to propagate the signal information through the path specified in it
            and returns the modified spectral information.
        """
        node = self.nodes[lightpath.path[0]]
        node.propagate(lightpath)

    def draw(self):
        """
            This function has to draw the network using matplotlib
            (nodes as dots and connection as lines).
        """
        fig = plt.figure()
        for label in self.nodes:
            node = self.nodes[label]
            x0 = node.position[0]
            y0 = node.position[1]
            plt.plot(x0, y0, 'ro', markersize=20, zorder=5)
            plt.text(x0, y0, label, fontsize=12, fontweight='semibold', zorder=10,
                     horizontalalignment='center', verticalalignment='center')
            for connected_node_label in node.connected_nodes:
                n1 = self.nodes[connected_node_label]
                x1 = n1.position[0]
                y1 = n1.position[1]
                plt.plot([x0, x1], [y0, y1], 'b', zorder=0, linewidth=2)
        plt.title('Network topology')
        fig.savefig('Network_topology.png')
        plt.show()

    # LAB 4
    def find_best_snr(self, snode, dnode):
        best_snr = 0
        best_path = ''
        ch = 0
        # Scan all available paths
        for path in self.weighted_paths.index:
            there_is_space = True
            # Make computations only if source and destination nodes match
            if path[0] == snode and path[-1] == dnode:
                # Check path's lines status
                for i in range(len(path) - 1):
                    if up.FREE not in self.lines[path[i] + path[i + 1]].state:
                        # First totally occupied line makes all path unfeasible
                        there_is_space = False
                        break
                    # if self.lines[path[i]+path[i+1]].state != FREE:
                    #     # First occupied line makes all path unfeasible
                    #     FREE = False
                    #     break
                # FREE, ch = find_ch(path)
                if self.weighted_paths.loc[path, 'SNR [dB]'] > best_snr and there_is_space:
                    ch = self.find_ch(path)
                    if ch != 0:
                        best_snr = self.weighted_paths.loc[path, 'SNR [dB]']
                        best_path = path
        return best_path, best_snr, ch

    def find_best_latency(self, snode, dnode):
        best_lat = 1000
        best_path = ''
        ch = 0
        # Scan all available paths
        for path in self.weighted_paths.index:
            there_is_space = True
            # Make computations only if source and destination nodes match
            if path[0] == snode and path[-1] == dnode:
                # Check path's lines status
                for i in range(len(path) - 1):
                    if up.FREE not in self.lines[path[i] + path[i + 1]].state:
                        # First totally occupied line makes all path unfeasible
                        there_is_space = False
                        break
                    # if self.lines[path[i]+path[i+1]].state != FREE:
                    #     # First occupied line makes all path unfeasible
                    #     FREE = False
                    #     break
                if self.weighted_paths.loc[path, 'Latency [s]'] < best_lat and there_is_space:
                    ch = self.find_ch(path)
                    if ch != 0:
                        best_lat = self.weighted_paths.loc[path, 'Latency [s]']
                        best_path = path
        return best_path, best_lat, ch

    def stream(self, connections, parameter='latency'):
        i = 1
        for connection in connections:
            if parameter == 'latency':
                path, best_lat, channel = self.find_best_latency(connection.input, connection.output)
            elif parameter == 'snr':
                path, best_snr, channel = self.find_best_snr(connection.input, connection.output)
            else:
                raise NameError('Wrong parameter: nor \'latency\' nor \'snr\' inserted')
            if path != '':
                bit_rate = self.calculate_bit_rate(path, self.nodes[path[0]].transceiver)
                connection.bit_rate = bit_rate
                if bit_rate > 0:
                    print(path, best_snr, channel, i)
                    i = i + 1
                    signal = LightPath(channel - 1, path)
                    self.propagate(signal)
                    if parameter == 'latency':
                        connection.latency = best_lat
                        connection.snr = 10 * np.log10(signal.signal_power / signal.noise_power)
                    else:
                        connection.latency = signal.latency
                        # connection.snr = 10 * np.log10(signal.signal_power / signal.noise_power)
                        connection.snr = best_snr
                    self.update_route_space(path)
                else:
                    connection.latency = 'None'
                    connection.snr = 0
            else:
                connection.latency = 'None'
                connection.snr = 0

        for node in self.nodes:
            self.nodes[node].switching_matrix = dict(self.default_switching_matrices[node])
        # for line in self.lines:
        #     self.lines[line].state = np.array([FREE] * 10)

        # for connection in connections:
        #     if parameter == 'latency':
        #         path, best_lat, channel = self.find_best_latency(connection.input, connection.output)
        #         if path == '' and best_lat == 1000:
        #             connection.latency = 'None'
        #             connection.snr = 0
        #         else:
        #             print(path, best_lat, channel, i)
        #             i = i + 1
        #             signal = LightPath(channel - 1, path)
        #             self.propagate(signal)
        #             connection.latency = signal.latency
        #             connection.snr = 10 * np.log10(signal.signal_power / signal.noise_power)
        #             self.update_route_space(path)
        #     elif parameter == 'snr':
        #         path, best_snr, channel = self.find_best_snr(connection.input, connection.output)
        #         if (path == '' and best_snr == 0) or channel == 0:
        #             connection.latency = 'None'
        #             connection.snr = 0
        #         else:
        #             print(path, best_snr, channel, i)
        #             i = i+1
        #             bit_rate = self.calculate_bit_rate(path, self.nodes[path[0]].transceiver)
        #             connection.bit_rate = bit_rate
        #             if bit_rate > 0:
        #                 signal = LightPath(channel - 1, path)
        #                 self.propagate(signal)
        #                 connection.latency = signal.latency
        #                 # connection.snr = 10 * np.log10(signal.signal_power / signal.noise_power)
        #                 connection.snr = best_snr
        #                 self.update_route_space(path)
        #     else:
        #         raise NameError('Wrong parameter: nor \'latency\' nor \'snr\' inserted')

    # LAB 5
    def probe(self, lightpath):
        """
            This function has to propagate the lightpath information through the path specified in it
            and returns the modified spectral information.
        """
        node = self.nodes[lightpath.path[0]]
        node.probe(lightpath)

    def build_route_space(self):
        route_space = pd.DataFrame(index=self.weighted_paths.index, columns=self.lines)
        for line in self.lines.values():
            for path in self.weighted_paths.index:
                if line.label in path:
                    route_space.loc[path][line.label] = deepcopy(line.state)
        self.route_space = route_space

    def update_route_space(self, path):
        # line = path[0]
        # for i in path[1:]:
        #     line += i
        #     for route in self.route_space.index:
        #         if line in route:
        #             self.route_space.loc[route][line] = deepcopy(self.lines[line].state)
        #             # linea sotto sbagliata ma per reference
        #             # self.route_space.loc[route][line] = self.lines[line].state * \
        #             #                                     self.nodes[i].switching_matrix[line[0]][line[1]]    # LAB 6
        #     line = i
        if len(path) < 3:
            for route in self.route_space.index:
                if path in route:
                    self.route_space.loc[route][path] = deepcopy(self.lines[path].state)
        else:
            for i in list(range(1, len(path)-1)):
                for j in range(2):
                    line = path[i-(1-j): i+(j+1)]
                    # print(path[i - 1], path[i + 1], '\t'+line)
                    for route in self.route_space.index:
                        if line in route:
                            # LAB 6
                            self.route_space.loc[route][line] = \
                                np.multiply(self.lines[line].state,
                                            self.nodes[path[i]].switching_matrix[path[i-1]][path[i+1]])

    def find_ch(self, path):
        row = self.route_space.loc[[path]]
        notnull_col = []
        free_indices = []
        for col in row:
            if not row[col].isnull().values.any():
                notnull_col.append(col)
                free_indices.append([i + 1 for i, x in enumerate(row[col].values.any()) if x == up.FREE])
        # common_index = set(free_indices[0])
        # for idx in free_indices[1:]:
        #     common_index.intersection_update(set(idx))
        common_index = set(free_indices[0]).intersection(*free_indices)
        if len(common_index) == 0:
            return 0
        else:
            return min(common_index)

    # LAB 6
    def build_switching_matrix(self, node, label1, my_dict):
        switching_matrix = {}
        switching_matrix[label1] = {}
        for label2 in self.nodes[node].connected_nodes:
            # if label1 == label2:
            # LAB7
            if 0 in my_dict[node]['switching_matrix'][label1][label2]:
                switching_matrix[label1][label2] = np.array([up.OCCUPIED] * 10)
            else:
                switching_matrix[label1][label2] = np.array([up.FREE] * 10)
        return switching_matrix

    # LAB 7
    def calculate_bit_rate(self, path, strategy):
        if strategy == 'fixed_rate':
            bit_rate = up.fixed_bit_rate(self.weighted_paths.loc[path, 'SNR [dB]'])
        elif strategy == 'flex_rate':
            bit_rate = up.flex_bit_rate(self.weighted_paths.loc[path, 'SNR [dB]'])
        elif strategy == 'shannon':
            bit_rate = up.shannon_bit_rate(self.weighted_paths.loc[path, 'SNR [dB]'])
        else:
            raise NameError('Wrong strategy: nor \'fixed_rate\' nor \'flex_rate\' nor \'shannon\' inserted')
        return bit_rate


class Connection:

    def __init__(self, snode, dnode):
        self.input = snode              # string
        self.output = dnode             # string
        self.signal_power = 1.0e-03     # float
        self.latency = 0.0              # float
        self.snr = 0.0                  # float
        self.bit_rate = 0.0                   # LAB 7 - float


# LAB 5
class LightPath(SignalInformation):

    def __init__(self, slot, path):
        SignalInformation.__init__(self, path)
        self.channel = slot         # integer
        self.symbol_rate = up.Rs
        self.df = up.DELTA_F
        # super().__init__(slot)
